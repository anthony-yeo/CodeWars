#Armstrong Number
~Number is equal to the cue of its each digit (153 -> 1^3 + 3^3 + 5^3 -> 1 + 27 + 125 = 153)
  public class ArmstrongNumber {
  
    ###### Run Code
    public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int n = sc.nextInt();
      sc.close();

      System.out.println("Number : " + n + " is " + (isArmStrong(n) ? "armstrong number" : "not a armstrong number"));

    }

    public static boolean isArmStrong(int number) {
      int result = 0;
      int orig = number;
      while (number != 0) {
        int remainder = number % 10;
        result = result + remainder * remainder * remainder;
        number = number / 10;
      }
      if (orig == result) {
        return true;
      }
      return false;
    }

    public static boolean isArmstrong(int input) {

      Integer number = 0;
      char[] s = ("" + input).toCharArray();

      for (char c : s) {
        number += Integer.valueOf("" + c) * Integer.valueOf("" + c) * Integer.valueOf("" + c);
        if (number.compareTo(input) == 1) {
          return false;
        }
      }

      if (number.compareTo(input) == 0) {
        return true;
      }
      return false;
    }

  }
----------------------------------------------------------------------- 

#Factorials
  import java.math.BigInteger; //used for values that contain a lot of digits, reference type instead of primitive, use .equals() when comparing
  import java.util.Scanner;

  public class Factorial {
  
    ###### Run Code
    public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      BigInteger i = sc.nextBigInteger();
      sc.close();

      System.out.println("Factorial of number, " + i + ", is : " + Fact(i));
    }

    public static BigInteger fact(BigInteger num) {
      if (num.compareTo(BigInteger.ZERO) == 0)
        return BigInteger.ONE;
      BigInteger fact = BigInteger.ONE;
      for (int i = num.intValue(); i > 0; i--) {
        fact = fact.multiply(BigInteger.valueOf(i));
      }
      return fact;
    }
   
    public static BigInteger Fact(BigInteger num) {
      if (num.compareTo(BigInteger.ZERO) == 0)
        return BigInteger.ONE;
      return num.multiply(Fact(num.subtract(BigInteger.ONE)));
    }
  }
-----------------------------------------------------------------------  
  
#Binary Search
    public class BinarySearch {

    public static int binarySearch(int number, int[] array) {
      int result = -1;
      int high = array.length;
      int low = 0;
      int mid;
      while(high >= low) {
        mid = (high + low) / 2;
        if (number < array[mid]) {
          high = mid - 1;
        } else if (number > array[mid]) {
          low = mid + 1;
        } else {
          result = mid;
          break;
        }

      }
      return result;
    }
    
    ###### Run Code
    public static void main(String[] args) {
      int[] array = new int[] {1, 2, 4, 7, 20, 29, 40, 54};
      int number = 20;
      System.out.println("Index of " + number + " in the array is " + binarySearch(number, array));
    }
  }
----------------------------------------------------------------------- 

#Fibonacci
 import java.math.BigInteger;
 import java.util.Scanner;
 
 public class FibonacciSeries {
 
  ######Run Code
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		sc.close();
		// BigInteger result = fibonacciRecursion(n); // it takes more time if n >= 35
		 BigInteger result = fibonacciNoRecursion(n);
		System.out.println(result);
	}
  
	/*
	 * using recursion to calculate fibonacci number is great, but it takes time
	 * when x getting bigger (try x = 40)
	 */
   
	public static BigInteger fibonacciRecursion(int x) {
		switch (x) {
		case 0:
			return BigInteger.ZERO;
		case 1:
			return BigInteger.ONE;
		default:
			return fibonacciRecursion(x - 1).add(fibonacciRecursion(x - 2));
		}
	}

	public static BigInteger fibonacciNoRecursion(int x) {
		if (x == 0 || x == 1) {
			return BigInteger.valueOf(x);
		} else {
			BigInteger a = BigInteger.ZERO, b = BigInteger.ONE;
			BigInteger r = BigInteger.ZERO;
			for (int i = 2; i <= x; i++) {
				r = a.add(b);
				a = b;
				b = r;
			}
			return r;
		}
	}
}
----------------------------------------------------------------------- 

